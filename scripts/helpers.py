from enum import Enum, auto
import re

# RegEx patterns
AUTHOR_CHARS = r"a-zA-Zßğö.\/_"
AUTHOR_REGEX = fr"(?<!OG )(?!OG )\b(?:van|[A-Z])[{AUTHOR_CHARS} ]+"
YEAR_REGEX = r"\d{4}[a-z]?"
BEGIN_INFO_REGEX = r"(?!al)[a-zA-Z]+\."  # To avoid matching "et al."
NUM_INFO_REGEX = r"(?:[A-Z\d\.]+(?:, |-))*[A-Z\d\.]+"
PREFIX_REGEX = r"\(|[a-z;] "
# Generated by ChatGPT
SPLIT_REGEX = r',(?!(?:[^()]*\([^()]*\))*[^()]*\)) '

# Used in multiple files
UNSURE_KEYWORDS = ["implied", "inferred", "can be", "ideally", "usually",
                   "most", "often", "if", "although"]
def isUnsure(name):
    return any(unsure in name for unsure in
               {"?", " (Testing)"}.union(f"({term}" for term in UNSURE_KEYWORDS))

class Rigidity(Enum):
    EXP = auto()
    IMP = auto()

    # Sources for discrepancies

def getSources(s):
    sources = re.findall(fr"\{{({AUTHOR_REGEX})({YEAR_REGEX})\}}", s)
    if "ISTQB" in s:
        sources.append(("ISTQB", "2024"))
    return sources

def categorizeSources(sources: str):
    if sources.startswith(("(implied")):
        return {Rigidity.IMP: getSources(sources)}
    elif "implied" in sources:
        parts = sources.split("implied by")
        parsed = {Rigidity.EXP: getSources(parts[0])}
        # Exclude implicit elements that are also explicit
        parsed[Rigidity.IMP] = [t for t in getSources(parts[1])
                                if t not in parsed[Rigidity.EXP]]
        return parsed
    else:
        return {Rigidity.EXP: getSources(sources)}

    # Sources for glossaries

def formatLineWithSources(line, todo=True):
    line = line.replace("(Hamburg and Mogyorodi, 2024)", "\\citepISTQB{}")
    line = line.replace("Hamburg and Mogyorodi, 2024", "\\citealpISTQB{}")

    for swebokAuthor in {"Washizaki", "Bourque and Fairley"}:
        line = line.replace(swebokAuthor, "SWEBOK")
    line = line.replace("ISO/IEC", "ISO_IEC")

    if todo:
        # Explicitly *want* to capture "OG"
        line = re.sub(fr"; (OG {AUTHOR_REGEX[15:]}(?:, {YEAR_REGEX}(?:, {BEGIN_INFO_REGEX} {NUM_INFO_REGEX})?)?)\)",
                    r"\\todo{\1})", line)

    line = re.sub(fr"({AUTHOR_REGEX}), ({YEAR_REGEX}), ({BEGIN_INFO_REGEX}) ({NUM_INFO_REGEX}); ({YEAR_REGEX}), ({BEGIN_INFO_REGEX}) ({NUM_INFO_REGEX})",
                  r"\\citealp[\3~\4]{\1\2}; \\citeyear[\6~\7]{\1\5}", line)
    line = re.sub(fr"\(({AUTHOR_REGEX}), ({YEAR_REGEX}), ({BEGIN_INFO_REGEX}) ({NUM_INFO_REGEX})\)",
                  r"\\citep[\3~\4]{\1\2}", line)
    line = re.sub(fr"({AUTHOR_REGEX}), ({YEAR_REGEX}), ({BEGIN_INFO_REGEX}) ({NUM_INFO_REGEX})",
                  r"\\citealp[\3~\4]{\1\2}", line)
    line = re.sub(fr"\(({AUTHOR_REGEX}), ({YEAR_REGEX})\)",
                  r"\\citep{\1\2}", line)
    line = re.sub(fr"({AUTHOR_REGEX}), ({YEAR_REGEX})",
                  r"\\citealp{\1\2}", line)

    line = line.replace(" et al.", "EtAl")
    line = line.replace("van V", "vanV")

    # if "17, 25" in line: input(line)

    line = re.sub(fr"\[([\w\d~.]+)\]{{(\w+)}}, ({BEGIN_INFO_REGEX}) ({NUM_INFO_REGEX})",
                  r"[\1,~\3~\4]{\2}", line)

    while True:
        newLine = re.sub(fr"({BEGIN_INFO_REGEX}(?:~[\d\.]+-?,)*) ({NUM_INFO_REGEX})",
                                r"\1~\2", line)
        if newLine == line:
            break
        line = newLine

    line = re.sub(r"\"([\w\s]*)\"", r"``\1''", line)

    return line

def parseSource(s: str):
    if isUnsure(s.lstrip("(")):
        s = s.lstrip("(").rstrip(")").split(";")
        i = [isUnsure(source) for source in s].index(True)
        s[i] = f"implied by {s[i]}"
        s = f"({';'.join(s)})"

    return formatLineWithSources(s, False)

# I/O
def readFileAsStr(filename) -> str:
    with open(filename, "r") as file:
        return "\n".join(file.readlines())

def writeFile(lines, filename, helper: bool = False, dir: str = "graphs"):
    lines = [line + '\n' for line in lines]
    if helper:
        filename = f"build/{filename}.tex"
    else:
        filename = f"assets/{dir}/{filename}.tex"

    try:
        with open(filename, "r", encoding="utf-8") as readFile:
            existingLines = readFile.readlines()
    except FileNotFoundError:
        existingLines = []

    if existingLines != lines:
        with open(filename, "w+", encoding="utf-8") as outFile:
            outFile.writelines(lines)
    # else:
    #     print(f"No changes to {filename}")