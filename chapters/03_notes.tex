\chapter{Notes}
\label{chap:notes}

\section{Software Metrics}
\label{chap:notes:sec:software-metrics}

\begin{itemize}
      \item The following branches of testing started as parts of quality
            testing:
            \begin{itemize}
                  \item Reliability testing \cite[p.~18, ch.~10]{fenton_software_1997}
                  \item Performance testing \cite[p.~18, ch.~7]{fenton_software_1997}
            \end{itemize}
      \item Reliability and maintainability can start to be tested even without
            code by ``measur[ing] structural attributes of representations of the
            software'' \cite[p.~18]{fenton_software_1997}
      \item The US Software Engineering Institute has a checklist for determining
            which types of lines of code are included when counting
            \cite[pp.~30-31]{fenton_software_1997}
      \item Measurements should include an entity to be measured, a specific
            attribute to measure, and the actual measure (i.e., units, starting
            state, ending state, what to include) \cite[p.~36]{fenton_software_1997}
            \begin{itemize}
                  \item These attributes must be defined before they can be
                        measured \cite[p.~38]{fenton_software_1997}
            \end{itemize}
\end{itemize}

\section{Software Testing}
\label{chap:notes:sec:software-testing}

\subsection{General Testing Notes}

\begin{itemize}
      \item Simple, normal test cases (test-to-pass) should always be developed
            and run before more complicated, unusual test cases (test-to-fail)
\end{itemize}

\subsection{Types of Testing}

\subsubsection{Dynamic Black-Box (Behavioural) Testing
      \cite[p.~64]{patton_software_2006}}

"Entering inputs, receiving outputs, and checking the results"
\cite[p.~64]{patton_software_2006}

\subsubsubsection{Requirements}
\begin{itemize}
      \item Requirements documentation (definition of what the software does)
            \cite[p.~64]{patton_software_2006}
\end{itemize}

\subsubsection{Exploratory Testing \cite[p.~65]{patton_software_2006}}

An alternative to dynamic black-box testing when a specification is not
available \cite[p.~65]{patton_software_2006}. The software is explored to
determine its features, and these features are then tested
\cite[p.~65]{patton_software_2006}. Finding any bugs using this method is a
positive thing \cite[p.~65]{patton_software_2006}, since despite not knowing
what the software \emph{should} do, you were able to determine that something
is wrong.

\subsubsection{Equivalence Partitioning/Classing \cite[p.~67]{patton_software_2006}}

The process of dividing the infinite set of test cases into a finite set that is
just as effective (i.e., by revealing the same bugs) \cite[p.~67]{patton_software_2006}.

\subsubsection{Data Testing \cite[p.~70]{patton_software_2006}}

The process of "checking that information the user inputs [and] results",
both final and intermediate, "are handled correctly" \cite[p.~70]{patton_software_2006}.

\subsubsubsection{Boundary Conditions \cite[p.~70]{patton_software_2006}}

"[S]ituations at the edge of the planned operational limits of the software"
\cite[p.~72]{patton_software_2006}. Often affects types of data (e.g., numeric,
speed, character, location, position, size, quantity
\cite[p.~72]{patton_software_2006}) each with its own set of (e.g., first/last,
min/max, start/finish, over/under, empty/full, shortest/longest,
slowest/fastest, soonest/latest, largest/smallest, highest/lowest,
next-to/farthest-from \cite[p.~72]{patton_software_2006}). Data at these
boundaries should be included in an equivalence partition, but so should
data in between them \cite[p.~73]{patton_software_2006}. Boundary conditions
should be tested using "the valid data just inside the boundary,
... the last possible valid data, and ... the invalid data just outside the
boundary" \cite[p.~73]{patton_software_2006}. \emph{Buffer overruns} are
"the number one cause of software security issues"
\cite[p.~75]{patton_software_2006}.
