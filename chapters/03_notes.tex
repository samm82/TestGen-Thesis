\chapter{Notes}
\label{chap:notes}

\section{A Survey of Metaprogramming Languages}
\label{chap:notes:sec:metalang-survey}

\begin{itemize}
      \item Often done with \acfp{ast}, \todo{investigate more: Steele 1990?}
            although other bases are used:
            \begin{itemize}
                  \item \acf{sst}, used by Dylan
                        \cite[p.~113:6]{lilis_survey_2019}
            \end{itemize}
      \item Allows for improvements in:
            \begin{itemize}
                  \item ``performance by generating efficient specialized
                        programs based on specifications instead of using
                        generic but inefficient programs''
                        \cite[p.~113:2]{lilis_survey_2019}
                  \item reasoning about object programs through ``analyzing
                        and discovering object-program characteristics that
                        enable applying further optimizations as well as
                        inspecting and validating the behavior of the object
                        program'' \cite[p.~113:2]{lilis_survey_2019}
                  \item code reuse through capturing ``code patterns that cannot
                        be abstracted'' \cite[p.~113:2]{lilis_survey_2019}
            \end{itemize}
\end{itemize}

\subsection{Definitions}

``\emph{Metaprogramming} is the process of writing computer programs, called
\emph{metaprograms}, that [can] \dots generate new programs or modify existing
ones'' \cite[p.~113:1]{lilis_survey_2019}.

\begin{itemize}
      \item Metalanguage: ``the language in which the metaprogram is written''
            \cite[p.~113:1]{lilis_survey_2019}
      \item Object language: ``the language in which the generated or
            transformed program is written'' \cite[p.~113:1]{lilis_survey_2019}
      \item Homogeneous metaprogramming: when ``the object language and the
            metalanguage are the same'' \cite[p.~113:1]{lilis_survey_2019}
      \item Heterogeneous metaprogramming: when ``the object language and the
            metalanguage are \dots different'' \cite[p.~113:1]{lilis_survey_2019}
\end{itemize}

\subsection{Metaprogramming Models}
\subsubsection{Macro Systems \cite[p.~113:3-7]{lilis_survey_2019}}
\begin{itemize}
      \item Map specified input sequences in a source file to corresponding
            output sequences (``macro expansion'') until no input sequences
            remain \cite[p.~113:3]{lilis_survey_2019}; this process can be:
            \begin{enumerate}
                  \item procedural (involving algorithms), or
                  \item pattern-based (only using pattern matching)
                        \cite[p.~113:4]{lilis_survey_2019}
            \end{enumerate}
      \item Must avoid variable capture (unintended name conflicts) by being
            ``hygienic'' \cite[p.~113:4]{lilis_survey_2019}; this may be
            overridden to allow for ``intentional variable capture'', such as
            Scheme's \emph{syntax-case} macro \cite[p.~113:5]{lilis_survey_2019}
\end{itemize}

\paragraph{Lexical Macros}
\begin{itemize}
      \item Language agnostic \cite[p.~113:3]{lilis_survey_2019}
      \item Usually only sufficient for basic metaprogramming since changes to
            the code without considering its meaning ``may cause unintended side
            effects or name clashes and may introduce difficult-to-solve bugs''
            \cite[p.~113:5]{lilis_survey_2019}
      \item Marco was the first safe, language-independent macro system that
            ``enforce[s] specific rules that can be checked by special oracles''
            for given languages (as long as the languages ``produce descriptive
            error messages'') \cite[p.~113:6]{lilis_survey_2019}
\end{itemize}

\paragraph{Syntactic Macros}
\begin{itemize}
      \item ``Aware of the language syntax and semantics''
            \cite[p.~113:3]{lilis_survey_2019}
      \item MS\textsuperscript{2} ``was the first programmable syntactic macro
            system for syntactically rich languages'', including by using ``a
            type system to ensure that all generated code fragments are
            syntactically correct'' \cite[p.~113:5]{lilis_survey_2019}
\end{itemize}

\subsubsection{Reflection Systems \cite[p.~113:7-9]{lilis_survey_2019}}
\begin{itemize}
      \item ``Perform computations on [themselves] in the same way as for the
            target application, enabling one to adjust the system behavior
            based on the needs of its execution''
            \cite[p.~113:7]{lilis_survey_2019}
      \item Requires that the system can examine (``introspection'') and modify
            (``intercession'') how it is represented
            \cite[p.~113:7]{lilis_survey_2019}
            \begin{itemize}
                  \item The representation of a system can either be structural
                        or behavioural (e.g., variable assignment)
                        \cite[p.~113:7]{lilis_survey_2019}
            \end{itemize}
      \item ``Runtime code generation based on source text can be impractical,
            inefficient, and unsafe, so alternatives have been explored based
            on \acsp{ast} and quasi-quote operators, offering a structured approach
            that is subject to typing for expressing and combining code at
            runtime'' \cite[p.~113:8]{lilis_survey_2019}
      \item ``Not limited to runtime systems'', as some ``compile-time systems
            \dots rely on some form of structural introspection to perform code
            generation'' \cite[p.~113:9]{lilis_survey_2019}
\end{itemize}

\subsubsection{\acfp{mop} \cite[p.~113:9-11]{lilis_survey_2019}}
\begin{itemize}
      \item ``Interfaces to the language enabling one to incrementally transform
            the original language behavior and implementation''
            \cite[p.~113:9]{lilis_survey_2019}
      \item Three different approaches:
            \begin{itemize}
                  \item Metaclass-based Approach: ``Classes are considered to be
                        objects of metaclasses, called metaobjects, that are
                        responsible for the overall behavior of the object
                        system'' \cite[p.~113:9]{lilis_survey_2019}
                  \item Metaobject-based Approach: ``Classes and metaobjects are
                        distinct'' \cite[p.~113:9]{lilis_survey_2019}
                  \item Message Reification Approach: used with message passing
                        \cite[p.~113:9]{lilis_survey_2019}
            \end{itemize}
      \item Can either be runtime (more common) or compile-time (e.g., OpenC++);
            the latter protocols ``operate as advanced macro systems that perform
            code transformation based on metaobjects rather than on text or
            \acsp{ast}'' \cite[p.~113:11]{lilis_survey_2019}
\end{itemize}

\paragraph{Dynamic Shells}
``Pseudo-objects with methods and instance variables that may be attached to
other objects'' that ``offer efficient and type-safe \acs{mop} functionality for
statically typed languages'' \cite[p.~113:10]{lilis_survey_2019}.

\paragraph{Dynamic Extensions}
``Offer similar functionality [to dynamic shells] but for classes, allowing a
program to replace the methods of a class and its subclasses by the methods of
another class at runtime'' \cite[p.~113:10]{lilis_survey_2019}.

\subsubsection{\acf{aop} \cite[p.~113:11-13]{lilis_survey_2019}}
\begin{itemize}
      \item The use of \emph{aspects}: ``modular units \dots [that] contain
            information about the additional behavior, called \emph{advice},
            that will be added to the base program by the aspect as well as
            the program locations, called \emph{join points}, where this extra
            behavior is to be inserted based on some matching criteria, called
            \emph{pointcuts}'' \cite[p.~113:12]{lilis_survey_2019}
      \item Weaving: the process of ``combining the base program with aspect
            code \dots [to form] the final code'' \cite[p.~113:12]{lilis_survey_2019}
      \item Two variants:
            \begin{enumerate}
                  \item Static \acs{aop}: when weaving takes place at compile
                        time, usually with ``a separate language and a custom
                        compiler, called [an] \emph{aspect weaver}''; results in
                        better performance \cite[p.~113:12]{lilis_survey_2019}
                  \item Dynamic \acs{aop}: when weaving takes place at runtime
                        by instrumenting ``the bytecode \dots to be able to
                        weave the aspect code''; provides more flexibility
                        \cite[p.~113:12]{lilis_survey_2019}
            \end{enumerate}
      \item This model originates from reflecting and \acsp{mop} (AspectS and
            AspectL ``support AOP by building respectively on the runtime
            \acsp{mop} of Smalltalk and Lisp'') \cite[p.~113:12]{lilis_survey_2019}
      \item While ``\acs{aop} can support metaprogramming by inserting code
            before, after, or around matched join points, as well as introducing
            data members and methods through intertype declarations'', it is
            usually done the other way around, as most \acs{aop} frameworks
            ``rely on metaprogramming techniques'' \cite[p.~113:12]{lilis_survey_2019}
\end{itemize}

\subsubsection{Generative Programming \cite[p.~113:13-17]{lilis_survey_2019}}
\begin{itemize}
      \item ``A software development paradigm based on modeling software system
            families such that, given a particular requirements specification,
            a highly customized and optimized intermediate or end-product can
            be automatically manufactured on demand from elementary, reusable
            implementation components by means of configuration knowledge''
            \todo{get original source from Czarnecki and Eisenecker 2000}
      \item Often done with an \acs{ast}
      \item Related to macro systems, but normal code and metacode are distinct
\end{itemize}

\paragraph{Template Systems \cite[p.~113:13-14]{lilis_survey_2019}}
\begin{itemize}
      \item Template code is instantiated with specific parameters to generate
            ALL code in a target language; ``no free-form source code generation
            is allowed'' \cite[p.~113:13]{lilis_survey_2019}
            \todo{clarify what ``free-form source code generation'' means}
      \item It is possible, though complex, to express any ``to express any
            generative metaprogram'', as long as ``the appropriate
            metaprogramming logic for type manipulation'' is present
            \cite[p.~113:14]{lilis_survey_2019}
\end{itemize}

\paragraph{\acs{ast} Transformations \cite[p.~113:14-15]{lilis_survey_2019}}
\begin{itemize}
      \item ``Offer code templates through quasi-quotation to support \acs{ast}
            creation and composition and complement them with \acs{ast}
            traversal or transformation features'' \cite[p.~113:14]{lilis_survey_2019}
\end{itemize}

\paragraph{Compile-Time Reflections \cite[p.~113:15-16]{lilis_survey_2019}}
\begin{itemize}
      \item ``Offer compile-time reflection features to enable generating code
            based on existing code structures'' while trying to ensure that ``the
            generator will always produce well-formed code'' (this is not always
            fully possible; for example, Genoupe ``cannot guarantee that the
            generated code is always well typed'')
            \cite[p.~113:15]{lilis_survey_2019}
\end{itemize}

\paragraph{Class Compositions \cite[p.~113:16-17]{lilis_survey_2019}}
\begin{itemize}
      \item Offer ``flexibility and expressiveness'' through composition
            approaches \cite[p.~113:16]{lilis_survey_2019}
            \begin{itemize}
                  \item \emph{Mixins}: \todo{Investigate}
                  \item \emph{Traits}: ``support a uniform, expressive, and
                        type-safe way for metaprogramming without resorting to
                        \acsp{ast}'' and offer ``compile-time pattern-based
                        reflection'' through parameterization
                        \cite[p.~113:16]{lilis_survey_2019}
            \end{itemize}
      \item Includes \emph{feature-oriented programming} approaches
            \todo{Investigate?}
\end{itemize}

\subsubsection{\acf{msp} \cite[p.~113:17-20]{lilis_survey_2019}}
\begin{itemize}
      \item ``Makes \dots [levels of evaluation] accessible to the programmer
            through \dots \emph{staging annotations}'' to ``specify the
            evaluation order of the program computations'' and work with these
            computation stages \cite[p.~113:17]{lilis_survey_2019}
      \item Related to program generation and procedural macro systems
            \cite[p.~113:17]{lilis_survey_2019}; macros are often implemented
            as multistage computations \cite[p.~113:18]{lilis_survey_2019}
      \item Languages that use \acs{msp} are called \emph{\acfp{msl}} or
            \emph{two-stage languages}, depending on how many stages of
            evaluation are offered \cite[p.~113:17]{lilis_survey_2019}
            \begin{itemize}
                  \item C++ first instantiates templates, then translates
                        nontemplate code \cite[p.~113:19]{lilis_survey_2019}
                  \item Template Haskell evaluates ``the top-level splices
                        to generate object-level code'' at compile time, then
                        executes the object-level code at runtime
                        \cite[p.~113:19]{lilis_survey_2019}
            \end{itemize}
      \item Often involves \emph{\acf{csp}}, which allows ``values \dots
            available in the current stage'' to be used in future stages
            \cite[p.~113:17]{lilis_survey_2019}
            \begin{itemize}
                  \item If this is used, \emph{cross-stage safety} is often
                        also used to prevent ``variables bound at some stage
                        \dots [from being] used at an earlier stage''
                        \cite[p.~113:17]{lilis_survey_2019}
            \end{itemize}
      \item Usually homogeneous, but there are exceptions; MetaHaskell, a
            modular framework \cite[p.~113:19]{lilis_survey_2019} with a type
            system, allows for ``heterogeneous metaprogramming with multiple
            object languages'' \cite[p.~113:18]{lilis_survey_2019}
      \item ``Type safety \dots comes at the cost of expressiveness''
            \cite[p.~113:19]{lilis_survey_2019}
\end{itemize}

\subsection{Phase of Evaluation}
\begin{itemize}
      \item ``In theory, any combination of them [the phases of evaluation] is
            viable; however, in practice most metalanguages offer only one or
            two of the options'' \cite[p.~113:20]{lilis_survey_2019}
      \item ``The phase of evaluation does not necessarily dictate the adoption
            of a particular metaprogramming model; however, there is a
            correlation between the two'' \cite[p.~113:20]{lilis_survey_2019}
\end{itemize}

\subsubsection{Preprocessing-Time Evaluation \cite[p.~113:20-21]{lilis_survey_2019}}
\begin{itemize}
      \item In \acf{pptmp}, ``metaprograms present in the original source are
            evaluated during the preprocessing phase and the resulting source
            file contains only normal program code and no metacode''
            \cite[p.~113:20]{lilis_survey_2019}
      \item These systems are called \emph{source-to-source preprocessors}
            \cite[p.~113:20]{lilis_survey_2019} and are usually examples of
            generative programming \cite[p.~113:21]{lilis_survey_2019}
            \begin{itemize}
                  \item ``All such cases involve syntactic transformations''
                        \cite[p.~113:21]{lilis_survey_2019}, usually using
                        \acsp{ast}
            \end{itemize}
      \item ``Translation can reuse the language compiler or interpreter
            without the need for any extensions'' \cite[p.~113:20]{lilis_survey_2019}
      \item Varying levels of complexity (e.g., these systems ``may be fully
            aware of the language syntax and semantics''
            \cite[p.~113:20]{lilis_survey_2019})
      \item Includes all lexical macro systems \cite[p.~113:20]{lilis_survey_2019}
      \item Typically doesn't use reflection, \acsp{mop}, or \acs{aop}
            (Reflective Java is an exception) \cite[p.~113:21]{lilis_survey_2019}
\end{itemize}

\subsubsection{Compilation-Time Evaluation \cite[p.~113:21-23]{lilis_survey_2019}}
\begin{itemize}
      \item In \acf{ctmp}, ``the language compiler is extended to handle
            metacode translation and execution'' \cite[p.~113:22]{lilis_survey_2019}
            \begin{itemize}
                  \item There are many ways of extending the compiler,
                        including ``plugins, syntactic additions, procedural or
                        rewrite-based \acs{ast} transformations, or multistage
                        translation'' \cite[p.~113:22]{lilis_survey_2019}
                  \item Metacode execution can be done by ``interpreting the
                        source metacode \dots or compiling the source metacode
                        to binary and then executing it''
                        \cite[p.~113:22]{lilis_survey_2019}
            \end{itemize}
      \item These systems are usually examples of generative programming
            \cite[p.~113:22]{lilis_survey_2019}
      \item Can use macro systems, \acsp{mop}, \acs{aop}
            \cite[p.~113:22]{lilis_survey_2019}, and/or reflection
            \cite[p.~113:23]{lilis_survey_2019}
\end{itemize}

\subsubsection{Execution-Time Evaluation \cite[p.~113:23-25]{lilis_survey_2019}}
\begin{itemize}
      \item \acf{rtmp} ``involves extending the language execution system and
            offering runtime libraries to enable dynamic code generation and
            execution'' and is ``the only case where it is possible to extend the
            system based on runtime state and execution''
            \cite[p.~113:23]{lilis_survey_2019}
      \item Includes ``most metaprogramming systems featuring \acsp{mop}''
            \cite[p.~113:24]{lilis_survey_2019}
      \item Can use reflection, \acsp{mop}, \acs{aop}, and/or \acs{msp}
            \cite[p.~113:23]{lilis_survey_2019}
\end{itemize}

\subsection{Metaprogram Source Location}
\subsubsection{Embedded in the Subject Program \cite[p.~113:25-26]{lilis_survey_2019}}
\begin{itemize}
      \item Usually occurs with macros, templates, \acsp{msl}, reflection,
            \acsp{mop}, and \acs{aop} \cite[p.~113:25]{lilis_survey_2019}
\end{itemize}

\paragraph{Context Unaware \cite[p.~113:25]{lilis_survey_2019}}
\begin{itemize}
      \item Occurs when metaprograms only need to know their input parameters
            to generate \acsp{ast} \cite[p.~113:25]{lilis_survey_2019}
      \item Very common; ``for most macro systems\dots, generative programming
            systems \dots and \acsp{msl} \dots it is the only available option''
            \cite[p.~113:25]{lilis_survey_2019}
\end{itemize}

\paragraph{Context Aware \cite[p.~113:25-26]{lilis_survey_2019}}
\begin{itemize}
      \item ``Typically involves providing access to the respective program
            \acs{ast} node and allowing it to be traversed'' as ``an extra \dots
            parameter to the metaprogram'' \cite[p.~113:25]{lilis_survey_2019}
      \item Allows for code transformation ``at multiple different locations
            reachable from the initial context'' \cite[p.~113:25]{lilis_survey_2019}
      \item Very uncommon \cite[p.~113:25]{lilis_survey_2019}
\end{itemize}

\paragraph{Global \cite[p.~113:26]{lilis_survey_2019}}
\begin{itemize}
      \item Involves ``scenarios that collectively introduce, transform, or
            remove functionality for the entire program''
            \cite[p.~113:26]{lilis_survey_2019}
      \item Usually occurs with reflection, \acsp{mop}, and \acs{aop}
            \cite[p.~113:26]{lilis_survey_2019}
      \item Can be used with ``any \acs{pptmp} or \acs{ctmp} system that
            provides access to the full program \acs{ast}''
            \cite[p.~113:26]{lilis_survey_2019}
      \item ``Can also be seen as a context-aware case where the context is the
            entire program'' \cite[p.~113:26]{lilis_survey_2019}
\end{itemize}

\subsubsection{External to the Subject Program \cite[p.~113:27]{lilis_survey_2019}}
\begin{itemize}
      \item Occurs when metaprograms ``are specified as separate transformation
            programs applied through \acs{pptmp} systems or supplied to the
            compiler together with the target program to be translated as extra
            parameters'' \cite[p.~113:27]{lilis_survey_2019}
      \item Includes many instances of \acs{aop} \cite[p.~113:27]{lilis_survey_2019}
\end{itemize}

\subsection{Relation to the Object Language}
\begin{itemize}
      \item Each metaprogramming language has two layers:
            \begin{enumerate}
                  \item ``The basic object language''
                  \item ``The metaprogramming elements for implementing the
                        metaprograms'' (the \emph{metalayer})
                        \cite[p.~113:27]{lilis_survey_2019}
            \end{enumerate}
      \item Sometimes the metalayer of a language is added to a language later,
            independently of the object language \cite[p.~113:27]{lilis_survey_2019}
\end{itemize}

\subsubsection{Metalanguage Indistinguishable from the Object Language
      \cite[p.~113:28-29]{lilis_survey_2019}}
\begin{itemize}
      \item Two categories:
            \begin{enumerate}
                  \item ``Object language and metalanguage \dots use the same
                        constructs through the same syntax''
                  \item ``Metalanguage constructs \dots [are] modeled using
                        object language syntax and applied through special
                        language or execution system features''
                        \cite[p.~113:28]{lilis_survey_2019}
                        \begin{itemize}
                              \item Includes many examples of \acsp{mop} and
                                    \acs{aop} \cite[p.~113:28]{lilis_survey_2019}
                        \end{itemize}
            \end{enumerate}
\end{itemize}

\subsubsection{Metalanguage Extends the Object Language
      \cite[p.~113:29]{lilis_survey_2019}}
\begin{itemize}
      \item Allows for reuse of ``the original [and well-known]
            \todo{can I do this if it's said later?} language
            features in developing metaprograms \dots instead of adopting
            custom programming constructs'' \cite[p.~113:29]{lilis_survey_2019}
      \item ``Typically involve new syntax and functionality used to
            differentiate normal code from metacode''
            \cite[p.~113:29]{lilis_survey_2019}
      \item Often used in quasi-quote constructs, two-stage and multistage
            languages, and \acsp{mop} \cite[p.~113:29]{lilis_survey_2019}
\end{itemize}

\subsubsection{Metalanguage Different from the Object Language
      \cite[p.~113:29-30]{lilis_survey_2019}}
\begin{itemize}
      \item Allows for ``the metalanguage syntax and constructs \dots [to be]
            selected to better reflect the metalanguage concepts to ease their
            use in developing metaprograms and enable them to become more
            concise and understandable'' \cite[p.~113:29]{lilis_survey_2019}
      \item However, it can lead to ``different development practices and
            disable[s] the potential for design or code reuse between them [the
                        languages]'', as well as requiring users to know how to
            use both languages \cite[p.~113:30]{lilis_survey_2019}
      \item Used by some \acs{aop} and generative metaprogramming systems
            \cite[p.~113:29]{lilis_survey_2019}
\end{itemize}

\section{Software Metrics}
\label{chap:notes:sec:software-metrics}

\begin{itemize}
      \item The following branches of testing started as parts of quality
            testing:
            \begin{itemize}
                  \item Reliability testing \cite[p.~18, ch.~10]{fenton_software_1997}
                  \item Performance testing \cite[p.~18, ch.~7]{fenton_software_1997}
            \end{itemize}
      \item Reliability and maintainability can start to be tested even without
            code by ``measur[ing] structural attributes of representations of the
            software'' \cite[p.~18]{fenton_software_1997}
      \item The US Software Engineering Institute has a checklist for determining
            which types of lines of code are included when counting
            \cite[pp.~30-31]{fenton_software_1997}
      \item Measurements should include an entity to be measured, a specific
            attribute to measure, and the actual measure (i.e., units, starting
            state, ending state, what to include) \cite[p.~36]{fenton_software_1997}
            \begin{itemize}
                  \item These attributes must be defined before they can be
                        measured \cite[p.~38]{fenton_software_1997}
            \end{itemize}
\end{itemize}

\section{Software Testing}
\label{chap:notes:sec:software-testing}

\subsection{General Testing Notes}

\begin{itemize}
      \item Simple, normal test cases (test-to-pass) should always be developed
            and run before more complicated, unusual test cases (test-to-fail)
            \cite[p.~66]{patton_software_2006}
\end{itemize}

\subsection{Types of Testing}

\subsubsection{Static Black-Box (Specification) Testing
      \cite[p.~56-62]{patton_software_2006}}

Most of this section is irrelevant to generating test cases, as they require
human involvement (e.g., Pretend to Be the Customer
\cite[p.~57-58]{patton_software_2006}, Research Existing Standards and
Guidelines \cite[p.~58-59]{patton_software_2006}). However, it provides a
``Specification Terminology Checklist'' \cite[p.~61]{patton_software_2006} that
includes some keywords that, if found, could trigger an applicable warning to
the user (similar to the idea behind the correctness/consistency checks
project):

\begin{itemize}
      \item \textbf{Potentially unrealistic:} always, every, all, none, every,
            certainly, therefore, clearly, obviously, evidently
      \item \textbf{Potentially vague:} some, sometimes, often, usually,
            ordinarily, customarily, most, mostly, good, high-quality, fast,
            quickly, cheap, inexpensive, efficient, small, stable
      \item \textbf{Potentially incomplete:} etc., and so forth, and so on,
            such as, handled, processed, rejected, skipped, eliminated,
            if \dots then \dots (without ``else'' or ``otherwise'')
\end{itemize}

\subsubsection{Dynamic Black-Box (Behavioural) Testing
      \cite[p.~64-65]{patton_software_2006}}

This is the process of ``entering inputs, receiving outputs, and checking the
results'' \cite[p.~64]{patton_software_2006}. Note that while black-box testing
is usually done at a higher (e.g., system) level, unit testing can also be
black-box \cite[p.~1]{jacob_comparative_2016}.

\paragraph{Requirements}
\begin{itemize}
      \item Requirements documentation (definition of what the software does)
            \cite[p.~64]{patton_software_2006}; relevant information could be:
            \begin{itemize}
                  \item Requirements: Input-Values and Output-Values
                  \item Input/output data constraints
            \end{itemize}
\end{itemize}

\subsubsection{Exploratory Testing \cite[p.~65]{patton_software_2006}}

An alternative to dynamic black-box testing when a specification is not
available \cite[p.~65]{patton_software_2006}. The software is explored to
determine its features, and these features are then tested
\cite[p.~65]{patton_software_2006}. Finding any bugs using this method is a
positive thing \cite[p.~65]{patton_software_2006}, since despite not knowing
what the software \emph{should} do, you were able to determine that something
is wrong.

This is not applicable to Drasil, because not only does it already generate a
specification, making this type of testing unnecessary, there is also a lot of
human-based trial and error required for this kind of testing
\cite{june_11_meeting}.

\subsubsection{Equivalence Partitioning/Classing \cite[p.~67-69]{patton_software_2006}}

The process of dividing the infinite set of test cases into a finite set that is
just as effective (i.e., by revealing the same bugs) \cite[p.~67]{patton_software_2006}.

\paragraph{Requirements}
\begin{itemize}
      \item Ranges of possible values \cite[p.~67]{patton_software_2006};
            could be obtained through:
            \begin{itemize}
                  \item Input/output data constraints
                  \item Case statements
            \end{itemize}
\end{itemize}

\subsubsection{Data Testing \cite[p.~70-79]{patton_software_2006}}

The process of ``checking that information the user inputs [and] results'',
both final and intermediate, ``are handled correctly'' \cite[p.~70]{patton_software_2006}.

\paragraph{Boundary Conditions \cite[p.~70-74]{patton_software_2006}}

``[S]ituations at the edge of the planned operational limits of the software''
\cite[p.~72]{patton_software_2006}. Often affects types of data (e.g., numeric,
speed, character, location, position, size, quantity
\cite[p.~72]{patton_software_2006}) each with its own set of (e.g., first/last,
min/max, start/finish, over/under, empty/full, shortest/longest,
slowest/fastest, soonest/latest, largest/smallest, highest/lowest,
next-to/farthest-from \cite[p.~72-73]{patton_software_2006}). Data at these
boundaries should be included in an equivalence partition, but so should
data in between them \cite[p.~73]{patton_software_2006}. Boundary conditions
should be tested using ``the valid data just inside the boundary,
\dots the last possible valid data, and \dots the invalid data just outside the
boundary'' \cite[p.~73]{patton_software_2006}.

\subparagraph{Requirements}
\begin{itemize}
      \item Ranges of possible values \cite[p.~67, 73]{patton_software_2006};
            could be obtained through:
            \begin{itemize}
                  \item Case statements
                  \item Input/output data constraints (e.g., inputs that
                        would lead to a boundary output)
            \end{itemize}
\end{itemize}

\subparagraph{Buffer Overruns \cite[p.~201-205]{patton_software_2006}}

\emph{Buffer overruns} are ``the number one cause of software security issues''
\cite[p.~75]{patton_software_2006}. They occur when the size of the destination
for some data is smaller than the data itself, causing existing data (including
code) to be overwritten and malicious code to potentially be injected
\cite[p.~202, 204-205]{patton_software_2006}. They often arise from bad
programming practices in ``languages [sic] such as C and C++, that lack safe
string handling functions'' \cite[p.~201]{patton_software_2006}. Any unsafe
versions of these functions that are used should be replaced with the
corresponding safe versions \cite[p.~203-204]{patton_software_2006}.

\paragraph{Sub-Boundary Conditions \cite[p.~75-77]{patton_software_2006}}

Boundary conditions ``that are internal to the software [but] aren't necessarily
apparent to an end user'' \cite[p.~75]{patton_software_2006}. These include
powers of two \cite[p.~75-76]{patton_software_2006} and ASCII and Unicode tables
\cite[p.~76-77]{patton_software_2006}.

While this is of interest to the domain of scientific computing, this is too
involved for Drasil right now, and the existing software constraints limit much
of the potential errors from over/underflow \cite{june_11_meeting}. Additionally,
strings are not really used as inputs to Drasil and only occur in output with
predefined values, so testing these values are unlikely to be fruitful.

\subparagraph{Requirements}
\begin{itemize}
      \item Increased knowledge of data type structures (e.g., monoids, rings,
            etc. \cite{june_11_meeting}); this would capture these sub-boundaries,
            as well as other information like relevant tests cases, along with
            our notion of these data types (\texttt{Space})
\end{itemize}

\paragraph{Default, Empty, Blank, Null, Zero, and None
      \cite[p.~77-78]{patton_software_2006}}

These should be their own equivalence class, since ``the software usually
handles them differently'' than ``the valid cases or \dots invalid cases''
\cite[p.~78]{patton_software_2006}.

Since these values may not always be applicable to a given scenario (e.g., a
test case for zero doesn't make sense if there is a constraint that the value
in question cannot be zero), the user should likely be able to select
categories of tests to generate instead of Drasil just generating all possible
test cases based on the inputs \cite{june_11_meeting}.

\subparagraph{Requirements}
\begin{itemize}
      \item Knowledge of an ``empty'' value for each \texttt{Space} (stored
            alongside each type in \texttt{Space}?)
      \item Knowledge of how input data could be omitted from an input
            (e.g., a missing command line argument, an empty line in a file);
            could be obtained from:
            \begin{itemize}
                  \item User responsibilities
            \end{itemize}
      \item Knowledge of how a programming language deals with \texttt{Null}
            values and how these can be passed as arguments
\end{itemize}

\paragraph{Invalid, Wrong, Incorrect, and Garbage Data
      \cite[p.~78-79]{patton_software_2006}}

This is testing-to-fail \cite[p.~77]{patton_software_2006}.

\subparagraph{Requirements}
This seems to be the most open-ended category of testing.
\begin{itemize}
      \item Specification of correct inputs that can be ignored;
            could be obtained through:
            \begin{itemize}
                  \item Input/output data constraints (e.g., inputs that would
                        lead to a violated output constraint)
                  \item Type information for each input (e.g., passing a string
                        instead of a number)
            \end{itemize}
\end{itemize}

\subsubsection{State Testing \cite[p.~79-87]{patton_software_2006}}

The process of testing ``a program's states and the transitions between them''
\cite[p.~79]{patton_software_2006}.

\paragraph{Logic Flow Testing \cite[p.~80-84]{patton_software_2006}}

This is done by creating a state transition diagram that includes:

\begin{itemize}
      \item Every possible unique state
      \item The condition(s) that take(s) the program between states
      \item The condition(s) and output(s) when a state is entered or exited
\end{itemize}

to map out the logic flow from the user's perspective
\cite[p.~81-82]{patton_software_2006}. Next, these states should be
partitioned using one (or more) of the following methods:

\begin{enumerate}
      \item Test each state once
      \item Test the most common state transitions
      \item Test the least common state transitions
      \item Test all error states and error return transitions
      \item Test random state transitions
            \cite[p.~82-83]{patton_software_2006}
\end{enumerate}

For all of these tests, the values of the state variables should be verified
\cite[p.~83]{patton_software_2006}.

\subparagraph{Requirements}
\begin{itemize}
      \item Knowledge of the different states of the program
            \cite[p.~82]{patton_software_2006}; could be obtained through:
            \begin{itemize}
                  \item The program's modules and/or functions
                  \item The program's exceptions
            \end{itemize}
      \item Knowledge about the different state transitions
            \cite[p.~82]{patton_software_2006}; could be obtained through:
            \begin{itemize}
                  \item Testing the state transitions near the beginning of a
                        workflow more?
            \end{itemize}
\end{itemize}

\paragraph{Testing States to Fail \cite[p.~84-87]{patton_software_2006}}

The goal here is to try and put the program in a fail state by doing things
that are out of the ordinary. These include:

\begin{itemize}
      \item Race Conditions and Bad Timing \cite[p.~85-86]{patton_software_2006}
            (Is this relevant to our examples?)
      \item Repetition Testing: ``doing the same operation over and over'',
            potentially up to ``thousands of attempts''
            \cite[p.~86]{patton_software_2006}
      \item Stress Testing: ``running the software under less-than-ideal conditions''
            \cite[p.~86]{patton_software_2006}
      \item Load testing: running the software with as large of a load as
            possible (e.g., large inputs, many peripherals)
            \cite[p.~86]{patton_software_2006}
\end{itemize}

\subparagraph{Requirements}
\begin{itemize}
      \item Repetition Testing: The types of operations that are likely to lead
            to errors when repeated (e.g., overwriting files?)
      \item Stress testing: can these be automated with pytest or are they
            outside our scope? % TODO: investigate
      \item Load testing: Knowledge about the types of inputs that could
            overload the system (e.g., upper bounds on values of certain types)
\end{itemize}

\subsubsection{Other Black-Box Testing \cite[p.~87-89]{patton_software_2006}}
\begin{itemize}
      \item Act like an inexperienced user (likely cannot be generated by Drasil)
      \item Look for bugs where they've already been found (keep track of
            previous failed test cases?)
      \item Think like a hacker (is this out of scope?)
      \item Follow experience (this will implicitly be done just by using Drasil)
\end{itemize}
